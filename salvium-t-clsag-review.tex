\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,hyperref,xurl}
\title{T-CLSAG Implementation Security Audit}
\author{Joshua Babb\thanks{\url{Cypher Stack}}}
\date{\today}

\begin{document}
\maketitle

This report describes the findings of a code audit of Salvium's T-CLSAG implementation.

\tableofcontents

\section{Overview}
\subsection{Introduction}
T-CLSAG (Two-scalar CLSAG) is a cryptographic signature scheme implemented in 
Salvium to support CARROT (Cryptonote Address on Rerandomizable RingCT Output Transactions) addressing, which uses dual-scalar secrets for enhanced 
privacy features.  The implementation extends the existing CLSAG signature system 
to handle transactions with dual-key CARROT addresses while maintaining anonymity, 
linkability, and unforgeability properties.  Because it protects sensitive 
cryptographic operations and financial transactions, rigorous scrutiny of the 
mathematical correctness and security implementation is essential.

\subsection{Audit goals \& methodology}
\begin{itemize}
  \item Evaluate mathematical compliance with the T-CLSAG specification.
  \item Inspect cryptographic implementation for correctness and security properties.
  \item Analyze multi-input transaction support and aggregation mechanisms.
  \item Review integration with existing RingCT and blockchain validation systems.
  \item Manual static analysis; no formal proofs or exhaustive testing campaigns.
\end{itemize}

\section{Scope}
Commit snapshot: Salvium codebase on \texttt{carrot-integration} branch as of commit \texttt{e5c9b05}.  Reviewed directories:
\begin{itemize}
  \item \texttt{salvium/src/ringct/}, \texttt{salvium/src/carrot\_core/}
  \item \texttt{salvium/src/carrot\_impl/}, \texttt{salvium/src/wallet/}
  \item \texttt{salvium/tests/unit\_tests/ringct.cpp}
\end{itemize}

Analysis focused on core T-CLSAG functions \texttt{TCLSAG\_Gen()}, \\
\texttt{proveRctTCLSAGSimple()}, \texttt{verRctTCLSAGSimple()}, and \\
\texttt{genRctSimpleCarrot()}.

\section{Summary of findings}
\begin{itemize}
  \item Implementation uses signature array approach rather than single 
        aggregated signature as specified.
  \item Mathematical operations are correctly implemented for single-input 
        T-CLSAG signatures.
  \item All cryptographic security properties are maintained across the 
        signature array architecture.
  \item Domain separator reuse from CLSAG represents a code hygiene issue 
        rather than a critical security vulnerability.
  \item Multi-input transaction support achieved through external aggregation 
        of individual signatures.
  \item Integration with blockchain validation and wallet systems is 
        comprehensive and correct.
\end{itemize}

\section{Technical Verification Details}

\subsection{Code Structure Verification}
The T-CLSAG implementation follows a clear architectural pattern:
\begin{itemize}
  \item \textbf{Core signature generation}: \texttt{TCLSAG\_Gen()} implements the cryptographic 
        protocol with dual-scalar support for CARROT addresses.
  \item \textbf{RingCT integration}: \texttt{proveRctTCLSAGSimple()} wraps the core function 
        for transaction-level usage.
  \item \textbf{Verification}: \texttt{verRctTCLSAGSimple()} implements the corresponding 
        verification algorithm with identical mathematical structure.
  \item \textbf{Transaction building}: \texttt{genRctSimpleCarrot()} orchestrates 
        transaction creation using a signature array approach.
\end{itemize}

\subsection{Mathematical Correctness Verification}
Key mathematical operations verified in the implementation:
\begin{itemize}
  \item \textbf{Key image computation}: $I = x \cdot H_p(K)$ correctly implemented 
        in \texttt{hwdev.clsag\_prepare\_carrot()} via \texttt{rct::scalarmultKey(I,H,p)} 
        where \texttt{H = H\_p(K)} and \texttt{p} represents the private key $x$.
  \item \textbf{Challenge computation}: Proper hash chain construction using \\
        \texttt{HASH\_KEY\_CLSAG\_ROUND} domain separator.
  \item \textbf{Dual-scalar signatures}: Both $s_x$ and $s_y$ components computed 
        via \texttt{hwdev.clsag\_sign()} and \texttt{hwdev.clsag\_sign\_y()}.
  \item \textbf{Verification equations}: Correct reconstruction of challenge values 
        in verification function.
\end{itemize}

\subsection{Security Implementation Verification}
Security-critical aspects confirmed:
\begin{itemize}
  \item \textbf{Domain separation}: Consistent use of CLSAG domain separators 
        (though T-CLSAG-specific separators would be preferable).
  \item \textbf{Randomness handling}: Proper generation and use of blinding factors.
  \item \textbf{Input validation}: Comprehensive size and consistency checks in \\
        \texttt{TCLSAG\_Gen()} function.
  \item \textbf{Hardware device support}: Integration with hardware security modules 
        through \texttt{hw::device} interface.
\end{itemize}

\section{Detailed findings}

\subsection{Architectural Deviation from Specification}
\paragraph{Problem}
The implementation creates an array of individual T-CLSAG signatures rather 
than a single signature with internal multi-input aggregation as described 
in the specification.  Analysis of \texttt{genRctSimpleCarrot()} in \\
\texttt{rctSigs.cpp:1609-1619} reveals a loop that generates separate 
signatures for each input:
\begin{verbatim}
for (size_t i = 0 ; i < inamounts.size(); i++) {
  rv.p.TCLSAGs[i] = proveRctTCLSAGSimple(full_message, 
    rv.mixRing[i], inSk[i].x, inSk[i].y, inSk[i].mask, 
    a[i], pseudoOuts[i], index[i], hwdev);
}
\end{verbatim}
The specification (t-clsag.tex:121) describes aggregation formulas \\
$W_i = \sum_{j=1}^{m} H_n(T_j, R, L_1, \ldots, L_m) \cdot K_{i,j}$ for 
creating a single signature covering multiple inputs, while the implementation 
processes each input independently.

\paragraph{Recommendation}
Consider documenting the architectural choice in code comments to clarify 
the deviation from specification.  Both approaches achieve equivalent security 
properties, but the difference should be explicitly acknowledged.  It may be 
beneficial to add specification references explaining why the signature array 
approach was chosen over internal aggregation.

\paragraph{Status}
This represents a valid architectural decision rather than an implementation 
error.  The signature array approach maintains all required cryptographic 
properties while potentially offering implementation simplicity benefits.

\subsection{Domain Separator Reuse from CLSAG}
\paragraph{Problem}
The T-CLSAG implementation reuses domain separators from the existing CLSAG 
implementation.  Analysis of \texttt{rctSigs.cpp} shows usage of 
\texttt{HASH\_KEY\_CLSAG\_AGG\_0}, \texttt{HASH\_KEY\_CLSAG\_AGG\_1}, and \\
\texttt{HASH\_KEY\_CLSAG\_ROUND} constants.  These constants are defined in \\
\texttt{cryptonote\_config.h:357-359} as:
\begin{verbatim}
const unsigned char HASH_KEY_CLSAG_ROUND[] = "CLSAG_round";
const unsigned char HASH_KEY_CLSAG_AGG_0[] = "CLSAG_agg_0";
const unsigned char HASH_KEY_CLSAG_AGG_1[] = "CLSAG_agg_1";
\end{verbatim}
While this does not create practical security vulnerabilities due to structural differences in hash 
inputs and mutually exclusive protocol usage, it violates cryptographic 
hygiene best practices for domain separation.

\paragraph{Recommendation}
Recommended fix is to define T-CLSAG specific domain separators such as 
\texttt{HASH\_KEY\_TCLSAG\_AGG\_0}, \texttt{HASH\_KEY\_TCLSAG\_AGG\_1}, and \\
\texttt{HASH\_KEY\_TCLSAG\_ROUND}.  This change can be implemented during 
routine maintenance without affecting security or functionality.

\paragraph{Status}
Low priority code hygiene issue.  The reuse does not pose immediate security 
risks due to protocol isolation and different hash input structures.

\subsection{Mathematical Equivalence in Single-Input Case}
\paragraph{Problem}
While the implementation differs architecturally from the specification, 
analysis reveals mathematical equivalence for single-input scenarios.  
The \texttt{mu\_P} and \texttt{mu\_C} aggregation scalars computed in 
\texttt{rctSigs.cpp:439-440} are calculated as:
\begin{verbatim}
mu_P = hash_to_scalar(mu_P_to_hash);
mu_C = hash_to_scalar(mu_C_to_hash);
\end{verbatim}
where \texttt{mu\_P\_to\_hash} contains the domain separator \texttt{HASH\_KEY\_CLSAG\_AGG\_0} 
followed by public keys $P[0..n-1]$ and commitments $C[0..n-1]$, and \texttt{mu\_C\_to\_hash} 
contains \texttt{HASH\_KEY\_CLSAG\_AGG\_1} followed by the same public keys, key image $I$, 
auxiliary point $D$, and commitment offset.  For single-input transactions ($m=1$), 
these produce results mathematically equivalent to the specification's 
$W_i = H_n(T_1, R, L_1) \cdot K_{i,1}$ and $\tilde{W} = H_n(T_1, R, L_1) \cdot L_1$ 
when the hash inputs are structured identically. However, this equivalence has not 
been formally documented or proven within the codebase.

\paragraph{Recommendation}
Consider adding mathematical documentation demonstrating the equivalence 
between the implementation approach and specification formulas for the 
single-input case.  Specifically, document how the implementation's computation:
\begin{verbatim}
mu_P * P[i] + mu_C * C[i]
\end{verbatim}
relates to the specification's aggregation formula \\$W_i = \sum_{j=1}^{m} H_n(T_j, R, L_1, \ldots, L_m) \cdot K_{i,j}$ 
when $m=1$.  The equivalence holds because both approaches compute a weighted combination 
of the same cryptographic elements, but use different organizational structures.

\subsection{Security Property Preservation}
\paragraph{Problem}
While the implementation uses a different architecture than specified, 
analysis confirms that all required cryptographic security properties are 
maintained.  Anonymity is preserved through individual signature anonymity, 
linkability is maintained via deterministic key image computation 
$L_j = x_j \cdot H_p(K_j)$, and unforgeability is ensured through the 
challenge-response protocol requiring knowledge of both $x$ and $y$ 
components.  However, formal security proofs for the signature array 
approach are not provided.

\paragraph{Recommendation}
Consider developing formal security arguments demonstrating that the signature 
array approach maintains equivalent security properties to the specification's 
single-signature model.  It may be beneficial to document the security property 
preservation explicitly in technical documentation.

\paragraph{Status}
Security properties verified through analysis, but formal documentation of 
the security equivalence between approaches would strengthen confidence in 
the implementation choice.

\subsection{Integration Quality and Test Coverage}
\paragraph{Problem}
Analysis reveals comprehensive integration with blockchain validation systems 
and wallet transaction building processes.  The implementation correctly 
integrates with T-CLSAG transaction types through \\\texttt{is\_rct\_tclsag(rv.type)} 
checks and provides proper serialization support via the 
\texttt{rv.p.TCLSAGs} vector.  Test coverage in \\\texttt{tests/unit\_tests/ringct.cpp:302-483} 
includes comprehensive T-CLSAG signature generation, verification, and edge case handling 
with tests for invalid signatures, tampered components, and boundary conditions.  
The test suite validates both \texttt{proveRctTCLSAGSimple()} and \texttt{verRctTCLSAGSimple()} 
functions extensively. However, specific multi-input test scenarios that exercise 
the signature array architecture are limited.

\paragraph{Recommendation}
Consider expanding test coverage to include explicit multi-input transaction 
scenarios that validate the signature array approach.  It may be beneficial 
to add performance benchmarks comparing single-input and multi-input 
transaction processing to ensure scalability characteristics are acceptable.

\paragraph{Status}
Integration quality is excellent, but enhanced testing of multi-input 
scenarios would provide additional confidence in the implementation's 
robustness across various transaction patterns.

\end{document}
